++++++++++++++++++
erl -name debug_local@127.0.0.1 -setcookie erlide -remsh loginserver@127.0.0.1

erl -name observer@127.0.0.1 -hidden -setcookie erlide -run observer

#ets
	ets:all() %列出所有的ETS Table 
	ets:i() %给出一个ETS Table的清单 包含表的类型,数据量,使用内存,所有者信息
	ets:i(zen_ets) % 输出zen_ets表的数据,
					个人感觉这个非常方便比tv还要简单快捷,如果表数据量很大,
					它还提供了一个分页显示的功能
    ets:info(zen_ets) %单独查看一个ETS Table的详细信息
						也可以使用这个方法,如果怀疑这个表被锁了
						可以使用ets:info(zen_ets,fixed)查看,ets:info(zen_ets,safe_fixed) 
						可以获得更多的信息,这样比较容易定位是哪个模块出了问题.
    ets:member(Tab, Key) -> true | false %看表里面是否存在键值为Key的数据项.

#查看系统所有进程
erlang:processes()
#查看进程当前调用
erlang:whereis(RegName)
erlang:process_info(pid, current_function)
#查看进程相关信息
[erlang:process_info(P,[
		registered_name,
		reductions,
		message_queue_len,
		message,
		memory,
		heap_size,
		stack_size,
		total_heap_size,
		current_function]) || P <- erlang:processes()].

将进程信息写入文件		
process_infos() ->
	filelib:ensure_dir("./log/"),
	File = "./log/processes_infos.log",
	{ok, Fd} = file:open(File, [write, raw, binary, append]),
	Fun = fun(Pi) ->
		Info = io_lib:format("=>~p \n\n", [Pi]),
		case filelib:is_file(File) of
			true -> file:write(Fd, Info);
			false ->
				file:close(Fd),
				{ok, NewFd} = file:open(File, [write, raw, binary, append]),
				file:write(NewFd, Info)
		end,
		timer:sleep(20)
	end,
	[Fun(erlang:process_info(P)) || P <- erlang:processes()].    

++++++++++++++++++
内存

1. 查看节点的内存瓶颈所在地方 erlang:memory(). / io:format("~s~n", [binary_to_list(erlang:system_info(info))]).
2. 查看占用内存最高的进程 spawn(fun()-> etop:start([{output, text}, {interval, 1}, {lines, 20}, {sort, memory}]) end).
3. 查看占用内存最高的进程状态 erlang:process_info(pid(0,12571,0)). 

或者 etop
etop:stop().

CPU
** nmon / dstat -tam, vtune 都能很好分析beam 瓶颈
1.erlang:statistics(scheduler_wall_time) 或者VTune分析/etop
2.%进程CPU占用排名
etop() -> spawn(fun() -> etop:start([{output, text}, {interval, 10}, {lines, 20}, {sort, reductions}]) end).